<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Hadoop学习笔记（四）数据的输入与输出 | IT小王</title><meta name="description" content="Hadoop学习笔记（四）数据的输入与输出"><meta name="keywords" content="Hadoop"><meta name="author" content="IT小王"><meta name="copyright" content="IT小王"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.svg"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hadoop学习笔记（四）数据的输入与输出"><meta name="twitter:description" content="Hadoop学习笔记（四）数据的输入与输出"><meta name="twitter:image" content="https://wangbowen.cn/postImages/HadoopCover.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Hadoop学习笔记（四）数据的输入与输出"><meta property="og:url" content="https://wangbowen.cn/2020/02/24/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"><meta property="og:site_name" content="IT小王"><meta property="og:description" content="Hadoop学习笔记（四）数据的输入与输出"><meta property="og:image" content="https://wangbowen.cn/postImages/HadoopCover.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://wangbowen.cn/2020/02/24/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"><link rel="prev" title="Hadoop学习笔记（五）HA" href="https://wangbowen.cn/2020/02/26/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89HA/"><link rel="next" title="Hexo使用入门" href="https://wangbowen.cn/2020/02/22/Hexo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"ELVDUY5WGR","apiKey":"55783f8f2945106559981cc355ad5d57","indexName":"hexoSearch","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://wangbowen.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-center"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">IT小王</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">28</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Hadoop学习笔记（四）数据的输入与输出"><span class="toc_mobile_items-text">Hadoop学习笔记（四）数据的输入与输出</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一、压缩和解压缩"><span class="toc_mobile_items-text">一、压缩和解压缩</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-进行压缩的原因"><span class="toc_mobile_items-text">1.1 进行压缩的原因</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-安装snappy压缩库-centos7-【未成功】"><span class="toc_mobile_items-text">1.2 安装snappy压缩库(centos7)【未成功】</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-代码示例"><span class="toc_mobile_items-text">1.4 代码示例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二、SequenceFile序列文件"><span class="toc_mobile_items-text">二、SequenceFile序列文件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-SquenceFile简介"><span class="toc_mobile_items-text">2.1 SquenceFile简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-同步标识"><span class="toc_mobile_items-text">2.2 同步标识</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-文件格式"><span class="toc_mobile_items-text">2.3 文件格式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4-压缩方式"><span class="toc_mobile_items-text">2.4 压缩方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-代码示例"><span class="toc_mobile_items-text">2.5 代码示例</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#写操作"><span class="toc_mobile_items-text">写操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#写操作（压缩）"><span class="toc_mobile_items-text">写操作（压缩）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#读操作1（key-value）"><span class="toc_mobile_items-text">读操作1（key, value）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#读操作2（key）"><span class="toc_mobile_items-text">读操作2（key）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#读操作3（seek）"><span class="toc_mobile_items-text">读操作3（seek）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#读操作4（sync）"><span class="toc_mobile_items-text">读操作4（sync）</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三、MapFile"><span class="toc_mobile_items-text">三、MapFile</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-简介"><span class="toc_mobile_items-text">3.1 简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2-使用"><span class="toc_mobile_items-text">3.2 使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四、MR程序文件输入输出格式"><span class="toc_mobile_items-text">四、MR程序文件输入输出格式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-设置单文件格式输入输出类型"><span class="toc_mobile_items-text">4.1 设置单文件格式输入输出类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-2-MultipleInputs多文件格式数据输入源"><span class="toc_mobile_items-text">4.2 MultipleInputs多文件格式数据输入源</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五、数据输入文件的处理"><span class="toc_mobile_items-text">五、数据输入文件的处理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-1-InputFormat"><span class="toc_mobile_items-text">5.1 InputFormat</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-2-Split切片"><span class="toc_mobile_items-text">5.2 Split切片</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-3-RecordReader读取法则"><span class="toc_mobile_items-text">5.3 RecordReader读取法则</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六、数据库读取与写入"><span class="toc_mobile_items-text">六、数据库读取与写入</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-1-数据库准备"><span class="toc_mobile_items-text">6.1 数据库准备</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-2-自定义数据对象类"><span class="toc_mobile_items-text">6.2 自定义数据对象类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-3-编写Mapper和Reducer"><span class="toc_mobile_items-text">6.3 编写Mapper和Reducer</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Mapper"><span class="toc_mobile_items-text">Mapper</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Reduce"><span class="toc_mobile_items-text">Reduce</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-4-编写App启动类"><span class="toc_mobile_items-text">6.4 编写App启动类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-5-添加pom依赖"><span class="toc_mobile_items-text">6.5 添加pom依赖</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-6-本地运行"><span class="toc_mobile_items-text">6.6 本地运行</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-7-集群运行"><span class="toc_mobile_items-text">6.7 集群运行</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hadoop学习笔记（四）数据的输入与输出"><span class="toc-text">Hadoop学习笔记（四）数据的输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、压缩和解压缩"><span class="toc-text">一、压缩和解压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-进行压缩的原因"><span class="toc-text">1.1 进行压缩的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-安装snappy压缩库-centos7-【未成功】"><span class="toc-text">1.2 安装snappy压缩库(centos7)【未成功】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-代码示例"><span class="toc-text">1.4 代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、SequenceFile序列文件"><span class="toc-text">二、SequenceFile序列文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-SquenceFile简介"><span class="toc-text">2.1 SquenceFile简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-同步标识"><span class="toc-text">2.2 同步标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-文件格式"><span class="toc-text">2.3 文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-压缩方式"><span class="toc-text">2.4 压缩方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-代码示例"><span class="toc-text">2.5 代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#写操作"><span class="toc-text">写操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写操作（压缩）"><span class="toc-text">写操作（压缩）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读操作1（key-value）"><span class="toc-text">读操作1（key, value）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读操作2（key）"><span class="toc-text">读操作2（key）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读操作3（seek）"><span class="toc-text">读操作3（seek）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读操作4（sync）"><span class="toc-text">读操作4（sync）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、MapFile"><span class="toc-text">三、MapFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-简介"><span class="toc-text">3.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-使用"><span class="toc-text">3.2 使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、MR程序文件输入输出格式"><span class="toc-text">四、MR程序文件输入输出格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-设置单文件格式输入输出类型"><span class="toc-text">4.1 设置单文件格式输入输出类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-MultipleInputs多文件格式数据输入源"><span class="toc-text">4.2 MultipleInputs多文件格式数据输入源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、数据输入文件的处理"><span class="toc-text">五、数据输入文件的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-InputFormat"><span class="toc-text">5.1 InputFormat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Split切片"><span class="toc-text">5.2 Split切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-RecordReader读取法则"><span class="toc-text">5.3 RecordReader读取法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、数据库读取与写入"><span class="toc-text">六、数据库读取与写入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-数据库准备"><span class="toc-text">6.1 数据库准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-自定义数据对象类"><span class="toc-text">6.2 自定义数据对象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-编写Mapper和Reducer"><span class="toc-text">6.3 编写Mapper和Reducer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mapper"><span class="toc-text">Mapper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reduce"><span class="toc-text">Reduce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-编写App启动类"><span class="toc-text">6.4 编写App启动类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-添加pom依赖"><span class="toc-text">6.5 添加pom依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-本地运行"><span class="toc-text">6.6 本地运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-集群运行"><span class="toc-text">6.7 集群运行</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/postImages/HadoopCover.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Hadoop学习笔记（四）数据的输入与输出</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-02-24<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-02-24</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/">Hadoop</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Hadoop学习笔记（四）数据的输入与输出"><a href="#Hadoop学习笔记（四）数据的输入与输出" class="headerlink" title="Hadoop学习笔记（四）数据的输入与输出"></a>Hadoop学习笔记（四）数据的输入与输出</h1><p>先来看一张流程图：</p>
<p><a href="/postImages/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F1.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F1.png" class="lazyload"></a></p>
<p>我们可以看到在MR前后还有一些关于文件输入与输出的内容。首先是InputFormat用来接受输入文件，并对其进行切片。然后通过RecordReader对这些切片进行读取数据，产生KV对再传给MAP来处理。</p>
<h2 id="一、压缩和解压缩"><a href="#一、压缩和解压缩" class="headerlink" title="一、压缩和解压缩"></a>一、压缩和解压缩</h2><p>在分析split切片的时候，有看到一个“可压缩”关键字。其实，在进行切片的时候，会先判断这个文件是否是可压缩的，那么这个压缩有什么用？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否可以切割代码片段</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isSplitable(job, path)) &#123;</span><br><span class="line">    <span class="keyword">long</span> blockSize = file.getBlockSize();</span><br><span class="line">    <span class="keyword">long</span> splitSize = <span class="keyword">this</span>.computeSplitSize(blockSize, minSize, maxSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> bytesRemaining;</span><br><span class="line">    <span class="keyword">int</span> blkIndex;</span><br><span class="line">    <span class="keyword">for</span>(bytesRemaining = length; (<span class="keyword">double</span>)bytesRemaining / (<span class="keyword">double</span>)splitSize &gt; <span class="number">1.1</span>D; bytesRemaining -= splitSize) &#123;</span><br><span class="line">        blkIndex = <span class="keyword">this</span>.getBlockIndex(blkLocations, length - bytesRemaining);</span><br><span class="line">        splits.add(<span class="keyword">this</span>.makeSplit(path, length - bytesRemaining, splitSize, blkLocations[blkIndex].getHosts(), blkLocations[blkIndex].getCachedHosts()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytesRemaining != <span class="number">0L</span>) &#123;</span><br><span class="line">        blkIndex = <span class="keyword">this</span>.getBlockIndex(blkLocations, length - bytesRemaining);</span><br><span class="line">        splits.add(<span class="keyword">this</span>.makeSplit(path, length - bytesRemaining, bytesRemaining, blkLocations[blkIndex].getHosts(), blkLocations[blkIndex].getCachedHosts()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled() &amp;&amp; length &gt; Math.min(file.getBlockSize(), minSize)) &#123;</span><br><span class="line">        LOG.debug(<span class="string">"File is not splittable so no parallelization is possible: "</span> + file.getPath());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="1-1-进行压缩的原因"><a href="#1-1-进行压缩的原因" class="headerlink" title="1.1 进行压缩的原因"></a>1.1 进行压缩的原因</h3><ol>
<li><p>通过压缩来减少文件传输量的大小，把网络带宽的压力转移给了CPU（因为需要解压、解压缩）。</p>
</li>
<li><p>很多元数据，而且又不经常用，那么就可以进行压缩后再存储，节省磁盘空间。</p>
</li>
</ol>
<h3 id="1-2-安装snappy压缩库-centos7-【未成功】"><a href="#1-2-安装snappy压缩库-centos7-【未成功】" class="headerlink" title="1.2 安装snappy压缩库(centos7)【未成功】"></a>1.2 安装snappy压缩库(centos7)【未成功】</h3><p>如果安装不了snappy可以试试下面的LZO。(反正我是没有成功)</p>
<p>步骤参考：<a href="https://blog.csdn.net/qq_27078095/article/details/56865443【在hadoop2.X集群中安装压缩工具snappy（主要用于hbase）】" target="_blank" rel="noopener">https://blog.csdn.net/qq_27078095/article/details/56865443【在hadoop2.X集群中安装压缩工具snappy（主要用于hbase）】</a></p>
<ol>
<li><p>安装支持环境</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y install gcc gcc-c++ libtool cmake zlib-devel maven</span><br><span class="line">（如果maven很慢参考手动安装）</span><br></pre></td></tr></table></figure></div>

<p>安装MAVEN</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.51cto.com&#x2F;13581826&#x2F;2093965</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>下载基础安装包</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop-2.6.0-cdh5.9.0-src.tar.gz（下载地址：http:&#x2F;&#x2F;archive.cloudera.com&#x2F;cdh5&#x2F;cdh&#x2F;5&#x2F;hadoop-2.6.0-cdh5.9.0-src.tar.gz，也可下载二进制包，内包含src源码：hadoop-2.6.0-cdh5.9.0-tar.gz）</span><br><span class="line"></span><br><span class="line">snappy1.1.1.tar.gz（下载地址：http:&#x2F;&#x2F;pkgs.fedoraproject.org&#x2F;repo&#x2F;pkgs&#x2F;snappy&#x2F;snappy-1.1.1.tar.gz&#x2F;8887e3b7253b22a31f5486bca3cbc1c2&#x2F;snappy-1.1.1.tar.gz）</span><br><span class="line"></span><br><span class="line">protobuf-2.5.0.tar.gz（下载地址：https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;protobuf&#x2F;releases&#x2F;tag&#x2F;v2.5.0 建议选择2.5.0版本，不支持最新版本）</span><br></pre></td></tr></table></figure></div>
</li>
<li><pre><code>下载地址
https://launchpad.net/ubuntu/+source/snappy/1.1.4-1
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 安装snappy</span><br></pre></td></tr></table></figure></div>
$tar -zxvf snappy-1.1.1.tar.gz
$cd snappy-1.1.1
$./configure
$make
$sudo make install
$ll /usr/local/lib/ | grep snappy    #查看snappy是否安装完成
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 安装protobuf（可能有点久）</span><br></pre></td></tr></table></figure></div>
$tar -zxvf protobuf-2.5.0.tar.gz
$cd protobuf-2.5.0
$./configure
$make
$sudo make install
$protoc --version        #验证安装
libprotoc 2.5.0
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 编译生成hadoop-native-Libraries（包括snappy）【据说很慢！原作者花了20小时？】</span><br></pre></td></tr></table></figure></div>
$tar -zxvf hadoop-2.6.0-cdh5.9.0-src.tar.gz
$cd hadoop-2.6.0-cdh5.9.0
$mvn package -DskipTests -Pdist,native -Dtar -Dsnappy.lib=/usr/local/lib -Dbundle.snappy
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">编译成功后，snappy的so文件会生成在如下目录：</span><br></pre></td></tr></table></figure></div>
hadoop-2.6.0-cdh5.9.0/hadoop-dist/target/hadoop-2.6.0-cdh5.9.0/lib/native
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">将此目录下的文件拷贝到hadoop集群中的hadoop下的lib&#x2F;native目录没有则新建，各节点均需拷贝。</span><br><span class="line"></span><br><span class="line">修改配置文件：</span><br></pre></td></tr></table></figure></div>
$cat core-site.xml
&lt;property&gt;
        &lt;name&gt;io.compression.codecs&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.io.compress.SnappyCodec&lt;/value&gt;
&lt;/property&gt;
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">测试是否安装成功:</span><br></pre></td></tr></table></figure></div>
$ hadoop checknative -a
hadoop:  true ...../hadoop-2.6.0-cdh5.9.0/lib/native/libhadoop.so
zlib:    true /usr/local/lib/libz.so.1
snappy:  true ...../hadoop-2.6.0-cdh5.9.0/lib/native/libsnappy.so.1
lz4:     true revision:10301
bzip2:   false 
openssl: true /lib64/libcrypto.so
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 1.3 安装LZO库文件</span><br><span class="line"></span><br><span class="line">如果上面的snappy安装不了，可以试试LZO。但是Hadoop中没有LZO的类，所以我们要手动安装。</span><br><span class="line"></span><br><span class="line">1. 修改项目pom文件</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;xml</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.anarres.lzo&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;lzo-hadoop&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></div></code></pre></li>
<li><p>在centos上安装lzo库</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sudo yum -y install lzo</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用mvn命令下载工件中的所有依赖</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入pom.xml所在目录，运行cmd：</span><br><span class="line">mvn -DoutputDirectory&#x3D;.&#x2F;lib -DgroupId&#x3D;XXX -DartifactId&#x3D;模块 -Dversion&#x3D;版本 dependency:copy-dependencies</span><br><span class="line"></span><br><span class="line">比如我自己的：</span><br><span class="line">mvn -DoutputDirectory&#x3D;.&#x2F;lib -DgroupId&#x3D;cn.wangbowen -DartifactId&#x3D;Hadoop -Dversion&#x3D;1.0-SNAPSHOT dependency:copy-dependencies</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在项目lib下会生成项目依赖所有的第三方jar</p>
</li>
<li><p>找出lzo-hadoop.jar + lzo-core.jar复制到hadoop的响应目录下</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cp lzo-core-1.0.0.jar &#x2F;soft&#x2F;hadoop&#x2F;share&#x2F;hadoop&#x2F;common&#x2F;lib&#x2F;</span><br><span class="line">$cp lzo-hadoop-1.0.0.jar &#x2F;soft&#x2F;hadoop&#x2F;share&#x2F;hadoop&#x2F;common&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure></div>



</li>
</ol>
<h3 id="1-4-代码示例"><a href="#1-4-代码示例" class="headerlink" title="1.4 代码示例"></a>1.4 代码示例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.wangbowen.hdfs.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.compress.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CompressUtils class</span></span><br><span class="line"><span class="comment"> * 压缩解压缩工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BoWenWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/19 16:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要压缩的文件路径[D:\tmp\a.txt]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_IN_FILE_PATH = <span class="string">"/home/wbw/tmp/a.txt"</span>;</span><br><span class="line">    <span class="comment">// 压缩文件输出路径（不加后缀名）[D:\tmp\b]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_OUT_FILE_PATH = <span class="string">"/home/wbw/tmp/b"</span>;</span><br><span class="line">    <span class="comment">// 需要解压的文件路径[D:\tmp\b]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNZIP_IN_FILE_PATH = <span class="string">"/home/wbw/tmp/b"</span>;</span><br><span class="line">    <span class="comment">// 输出解压文件路径（不加后缀名）[D:\tmp\c]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNZIP_OUT_FILE_PATH = <span class="string">"/home/wbw/tmp/c"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class[] zipClasses = &#123;</span><br><span class="line">                DeflateCodec<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">GzipCodec</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">BZip2Codec</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">Lz4Codec</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                //<span class="title">SnappyCodec</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">                <span class="title">com</span>.<span class="title">hadoop</span>.<span class="title">compression</span>.<span class="title">lzo</span>.<span class="title">LzoCodec</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">        &#125;</span>;</span><br><span class="line">        System.out.println(<span class="string">"=========== ZIP ==========="</span>);</span><br><span class="line">        <span class="keyword">for</span>(Class c : zipClasses)&#123;</span><br><span class="line">            zip(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"========== UNZIP =========="</span>);</span><br><span class="line">        <span class="keyword">for</span>(Class c : zipClasses)&#123;</span><br><span class="line">            unzip(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zip</span><span class="params">(Class codecClass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        CompressionCodec codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass, <span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="comment">// 创建文件输出流,得到默认扩展名</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(ZIP_OUT_FILE_PATH + codec.getDefaultExtension());</span><br><span class="line">        <span class="comment">// 得到压缩流Output</span></span><br><span class="line">        CompressionOutputStream zipOut = codec.createOutputStream(fos);</span><br><span class="line">        IOUtils.copyBytes(<span class="keyword">new</span> FileInputStream(ZIP_IN_FILE_PATH), zipOut, <span class="number">1024</span>);</span><br><span class="line">        zipOut.close();</span><br><span class="line">        System.out.println(<span class="string">"Zip["</span> + codecClass.getSimpleName() + <span class="string">"]: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unzip</span><span class="params">(Class codecClass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        CompressionCodec codec = (CompressionCodec)ReflectionUtils.newInstance(codecClass, <span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="comment">// 创建文件输入流,得到默认扩展名</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(UNZIP_IN_FILE_PATH + codec.getDefaultExtension());</span><br><span class="line">        <span class="comment">// 得到压缩流Input</span></span><br><span class="line">        CompressionInputStream zipIn = codec.createInputStream(fis);</span><br><span class="line">        IOUtils.copyBytes(zipIn,<span class="keyword">new</span> FileOutputStream(UNZIP_OUT_FILE_PATH + codec.getDefaultExtension() + <span class="string">".txt"</span>), <span class="number">1024</span>);</span><br><span class="line">        zipIn.close();</span><br><span class="line">        System.out.println(<span class="string">"UnZip["</span> + codecClass.getSimpleName() + <span class="string">"]: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ZIP &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2020-02-19 21:40:02,200 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</span><br><span class="line">2020-02-19 21:40:02,278 INFO compress.CodecPool: Got brand-new compressor [.deflate]</span><br><span class="line">Zip[DeflateCodec]: 541ms</span><br><span class="line">2020-02-19 21:40:02,446 INFO compress.CodecPool: Got brand-new compressor [.gz]</span><br><span class="line">Zip[GzipCodec]: 173ms</span><br><span class="line">2020-02-19 21:40:02,626 WARN bzip2.Bzip2Factory: Failed to load&#x2F;initialize native-bzip2 library system-native, will use pure-Java version</span><br><span class="line">2020-02-19 21:40:02,627 INFO compress.CodecPool: Got brand-new compressor [.bz2]</span><br><span class="line">Zip[BZip2Codec]: 9194ms</span><br><span class="line">2020-02-19 21:40:11,828 INFO compress.CodecPool: Got brand-new compressor [.lz4]</span><br><span class="line">Zip[Lz4Codec]: 136ms</span><br><span class="line">Zip[LzoCodec]: 232ms</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; UNZIP &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2020-02-19 21:40:12,119 INFO compress.CodecPool: Got brand-new decompressor [.deflate]</span><br><span class="line">UnZip[DeflateCodec]: 122ms</span><br><span class="line">2020-02-19 21:40:12,241 INFO compress.CodecPool: Got brand-new decompressor [.gz]</span><br><span class="line">UnZip[GzipCodec]: 80ms</span><br><span class="line">2020-02-19 21:40:12,356 INFO compress.CodecPool: Got brand-new decompressor [.bz2]</span><br><span class="line">UnZip[BZip2Codec]: 1200ms</span><br><span class="line">2020-02-19 21:40:13,531 INFO compress.CodecPool: Got brand-new decompressor [.lz4]</span><br><span class="line">UnZip[Lz4Codec]: 77ms</span><br><span class="line">UnZip[LzoCodec]: 150ms</span><br></pre></td></tr></table></figure></div>



<h2 id="二、SequenceFile序列文件"><a href="#二、SequenceFile序列文件" class="headerlink" title="二、SequenceFile序列文件"></a>二、SequenceFile序列文件</h2><h3 id="2-1-SquenceFile简介"><a href="#2-1-SquenceFile简介" class="headerlink" title="2.1 SquenceFile简介"></a>2.1 SquenceFile简介</h3><ul>
<li>sequenceFile文件是Hadoop用来存储“二进制”形式的[Key,Value]对而设计的一种平面文件(Flat File)。</li>
<li>可以把SequenceFile当做是一个容器，把所有的文件打包到SequenceFile类中可以高效的对小文件进行存储和处理。</li>
<li>SequenceFile文件并不按照其存储的Key进行排序存储，SequenceFile的内部类Writer提供了append功能。</li>
<li>SequenceFile中的Key和Value可以是任意类型Writable或者是自定义Writable。</li>
</ul>
<h3 id="2-2-同步标识"><a href="#2-2-同步标识" class="headerlink" title="2.2 同步标识"></a>2.2 同步标识</h3><p>同步标识，用于快速定位到记录的边界。同时因为有同步点，因此可切割（splitable）。</p>
<p>每条Record（记录）以键值对的方式进行存储，用来表示它的字符数组可以一次解析成：记录的长度、Key的长度、Key值和value值，并且Value值的结构取决于该记录是否被压缩。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reader.sync(pos);	<span class="comment">//定位到pos之后的第一个同步点</span></span><br><span class="line">writer.sync();		<span class="comment">//写入同步点</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-文件格式"><a href="#2-3-文件格式" class="headerlink" title="2.3 文件格式"></a>2.3 文件格式</h3><p>​        顺序文件由文件头和随后的一条或多条记录组成，顺序文件的前三个字节为SEQ(顺序文件代码),紧随其后的一个字节表示顺序文件的版本号。文件头还包括其他字段,例如键和值类的名称、数据压缩细节、用户定义的元数据以及同步标识。如前所述,同步标识用于在读取文件时能够从任意位置开始识别记录边界。每个文件都有一个随机生成的同步标识,其值存储在文件头中。同步标识位于顺序文件中的记录与记录之间。同步标识的额外存储开销要求小于1%,所以没有必要在每条记录末尾添加该标识(特别是比较短的记录)</p>
<p>​        注意生成的文件不可查看，会乱码，但是可以通过：hdfs dfs -text filepath 来查看内容。</p>
<h3 id="2-4-压缩方式"><a href="#2-4-压缩方式" class="headerlink" title="2.4 压缩方式"></a>2.4 压缩方式</h3><ul>
<li>不压缩：</li>
<li>record压缩：只压缩value</li>
<li>块压缩：按照多个record形成一个block</li>
</ul>
<p>推荐：<a href="https://blog.csdn.net/qq_33813365/article/details/82864241" target="_blank" rel="noopener">https://blog.csdn.net/qq_33813365/article/details/82864241</a></p>
<h3 id="2-5-代码示例"><a href="#2-5-代码示例" class="headerlink" title="2.5 代码示例"></a>2.5 代码示例</h3><p>单元测试前置代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqFileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">private</span> Configuration conf;</span><br><span class="line">    <span class="keyword">private</span> Path filePath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        conf.set(<span class="string">"fs.defaultFS"</span>, <span class="string">"file:///"</span>);</span><br><span class="line">        fs = FileSystem.get(conf);</span><br><span class="line">        filePath = <span class="keyword">new</span> Path(<span class="string">"d:/tmp/seq/1.seq"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试写入操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, filePath, IntWritable<span class="class">.<span class="keyword">class</span>, <span class="title">Text</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 写入操作</span></span><br><span class="line">        writer.append(<span class="keyword">new</span> IntWritable(i), <span class="keyword">new</span> Text(<span class="string">"tom"</span> + i));</span><br><span class="line">        <span class="comment">//每条记录后添加一个同步点</span></span><br><span class="line">        writer.sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        writer.append(<span class="keyword">new</span> IntWritable(i), <span class="keyword">new</span> Text(<span class="string">"tom"</span> + i));</span><br><span class="line">        <span class="comment">// 隔一个添加一个同步点</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            writer.sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="写操作（压缩）"><a href="#写操作（压缩）" class="headerlink" title="写操作（压缩）"></a>写操作（压缩）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试写入操作（压缩）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteGzip</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 多了2个参数（一个是方式，一个是压缩类）</span></span><br><span class="line">    SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, filePath, IntWritable<span class="class">.<span class="keyword">class</span>, <span class="title">Text</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                                                           <span class="title">SequenceFile</span>.<span class="title">CompressionType</span>.<span class="title">RECORD</span>, <span class="title">new</span> <span class="title">GzipCodec</span>())</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        writer.append(<span class="keyword">new</span> IntWritable(i), <span class="keyword">new</span> Text(<span class="string">"tom"</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="读操作1（key-value）"><a href="#读操作1（key-value）" class="headerlink" title="读操作1（key, value）"></a>读操作1（key, value）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试读操作</span></span><br><span class="line"><span class="comment"> * 方式一：通过 reader.next(key, value)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SequenceFile.Reader reader = <span class="keyword">new</span> SequenceFile.Reader(fs, filePath, conf);</span><br><span class="line">    IntWritable key = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    Text value = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (reader.next(key, value)) &#123;</span><br><span class="line">        System.out.println(key.get() + <span class="string">":"</span> + value.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="读操作2（key）"><a href="#读操作2（key）" class="headerlink" title="读操作2（key）"></a>读操作2（key）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试读操作</span></span><br><span class="line"><span class="comment"> * 方式二：通过 reader.next(key)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SequenceFile.Reader reader = <span class="keyword">new</span> SequenceFile.Reader(fs, filePath, conf);</span><br><span class="line">    IntWritable key = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    Text value = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="keyword">while</span> (reader.next(key)) &#123;</span><br><span class="line">        reader.getCurrentValue(value);</span><br><span class="line">        System.out.println(key.get() + <span class="string">":"</span> + value.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="读操作3（seek）"><a href="#读操作3（seek）" class="headerlink" title="读操作3（seek）"></a>读操作3（seek）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试读操作</span></span><br><span class="line"><span class="comment"> * 方式三：通过 reader.seek(pos)</span></span><br><span class="line"><span class="comment"> * 先通过方式一，调用reader.getPosition()获取每条记录的偏移量。</span></span><br><span class="line"><span class="comment"> * （本次测试偏移量为：153,198,243,288,333,378,423,448,493,518）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SequenceFile.Reader reader = <span class="keyword">new</span> SequenceFile.Reader(fs, filePath, conf);</span><br><span class="line">    IntWritable key = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    Text value = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="comment">// 243为记录起始位置：运行结果成功！</span></span><br><span class="line">    reader.seek(<span class="number">243</span>);</span><br><span class="line">    reader.next(key, value);</span><br><span class="line">    System.out.println(value.toString());</span><br><span class="line">    <span class="comment">// 245为记录中间位置：运行结果失败，抛出异常！</span></span><br><span class="line">    reader.seek(<span class="number">245</span>);</span><br><span class="line">    reader.next(key, value);</span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由上面代码可以看出，seek()定位操作，只能刚好定位到一条记录的起始位置，不然调用next()时候会抛异常。</p>
<p>同时，可以看到前面中间偏移量间隔是45字节，后面有部分是25字节。应该是检查点占了20字节。</p>
<h4 id="读操作4（sync）"><a href="#读操作4（sync）" class="headerlink" title="读操作4（sync）"></a>读操作4（sync）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试读操作</span></span><br><span class="line"><span class="comment"> * 方式四：通过 reader.sync(pos)</span></span><br><span class="line"><span class="comment"> * 先通过方式一，调用reader.getPosition()获取每条记录的偏移量。</span></span><br><span class="line"><span class="comment"> * （本次测试偏移量为：153,198,243,288,333,378,423,448,493,518）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SequenceFile.Reader reader = <span class="keyword">new</span> SequenceFile.Reader(fs, filePath, conf);</span><br><span class="line">    IntWritable key = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    Text value = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="comment">// 155为偏移量中间位置，结果不会报错</span></span><br><span class="line">    reader.sync(<span class="number">155</span>);</span><br><span class="line">    reader.next(key, value);</span><br><span class="line">    System.out.println(value.toString());</span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="三、MapFile"><a href="#三、MapFile" class="headerlink" title="三、MapFile"></a>三、MapFile</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>一个MapFile可以通过SequenceFile的地址，进行分类查找的格式。</p>
<p>使用这个格式的优点在于：</p>
<ul>
<li><p>与SequenceFile只生成一个文件不同，MapFile生成一个目录，目录下有index和data文件,都是序列文件。</p>
<p><a href="/postImages/MapFile.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/MapFile.png" class="lazyload"></a><br>可以看到index文件里面左边的是记录的索引，右边的代表数据在data文件的位置。</p>
</li>
<li><p>首先会将SequenceFile中的地址都加载入内存，并且进行了key升序写入(可重复)。</p>
</li>
<li><p>index文件划分key区间,用于快速定位，从而提供更快的数据查找。</p>
</li>
<li><p>索引模型按128个键建立的（可以看到上面图中左边一列以128递增），可以通过io.map.index.interval来修改</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>文件不支持复写操作，不能向已存在的SequenceFile(MapFile)追加存储记录</li>
<li>当write流不关闭的时候，没有办法构造read流。也就是在执行文件写操作的时候，该文件是不可读取的 </li>
</ul>
<h3 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h3><ul>
<li>MapFile和SequenceFile使用一样只要把类名替换，把输出路径由具体文件名改为目录就行。</li>
<li>查看文件内容也是要命令（hdfs dfs -text filepath）</li>
</ul>
<h2 id="四、MR程序文件输入输出格式"><a href="#四、MR程序文件输入输出格式" class="headerlink" title="四、MR程序文件输入输出格式"></a>四、MR程序文件输入输出格式</h2><h3 id="4-1-设置单文件格式输入输出类型"><a href="#4-1-设置单文件格式输入输出类型" class="headerlink" title="4.1 设置单文件格式输入输出类型"></a>4.1 设置单文件格式输入输出类型</h3><p>介绍了多种文件输入类型后，我们知道输入和输出可以有不同的格式。其中我们拿文件格式SequenceFile来举例：</p>
<ol>
<li><p>首先我们修改之前的单词计数程序，增加指定格式文件输入输出</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置文件输入/输出格式</span></span><br><span class="line">job.setInputFormatClass(TextInputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">job.setOutputFormatClass(SequenceFileOutputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>然后运行程序，将输出文件放到HDFS上查看</p>
<p><a href="/postImages/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F2.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F2.png" class="lazyload"></a></p>
<p>可以发现，输出改为SequenceFile后，用普通的-cat无法查看，而-text可以</p>
</li>
</ol>
<h3 id="4-2-MultipleInputs多文件格式数据输入源"><a href="#4-2-MultipleInputs多文件格式数据输入源" class="headerlink" title="4.2 MultipleInputs多文件格式数据输入源"></a>4.2 MultipleInputs多文件格式数据输入源</h3><p>如果输入数据文件有多种混合类型，可以用MultipleInputs.addInputPath()进行操作。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多个输入</span></span><br><span class="line">MultipleInputs.addInputPath(job,<span class="keyword">new</span> Path(<span class="string">"file:///d:/mr/txt"</span>),TextInputFormat<span class="class">.<span class="keyword">class</span>, <span class="title">WCTextMapper</span>.<span class="title">class</span>)</span>;</span><br><span class="line">MultipleInputs.addInputPath(job,<span class="keyword">new</span> Path(<span class="string">"file:///d:/mr/seq"</span>), SequenceFileInputFormat<span class="class">.<span class="keyword">class</span>,<span class="title">WCSeqMapper</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure></div>



<h2 id="五、数据输入文件的处理"><a href="#五、数据输入文件的处理" class="headerlink" title="五、数据输入文件的处理"></a>五、数据输入文件的处理</h2><h3 id="5-1-InputFormat"><a href="#5-1-InputFormat" class="headerlink" title="5.1 InputFormat"></a>5.1 InputFormat</h3><ol>
<li><p>获取切片集合</p>
</li>
<li><p>子类都要重写方法isSplittable()</p>
</li>
<li><p>负责创建RecordReader对象</p>
<p><a href="/postImages/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE2.png" class="lazyload"></a></p>
<p>可以看到对于不同类型的InputFormat其都有自己的Reader。</p>
</li>
<li><p>设置IO路径</p>
</li>
</ol>
<h3 id="5-2-Split切片"><a href="#5-2-Split切片" class="headerlink" title="5.2 Split切片"></a>5.2 Split切片</h3><ol>
<li><p>我们根据上次的JOB提交分析，可以留意到在job提交过程中有一个方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maps = <span class="keyword">this</span>.writeSplits(job, submitJobDir);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>单步调试进入该方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">writeSplits</span><span class="params">(JobContext job, Path jobSubmitDir)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 得到配置信息</span></span><br><span class="line">    JobConf jConf = (JobConf)job.getConfiguration();</span><br><span class="line">    <span class="keyword">int</span> maps;</span><br><span class="line">    <span class="comment">// 获取一个新的map</span></span><br><span class="line">    <span class="keyword">if</span> (jConf.getUseNewMapper()) &#123;</span><br><span class="line">        maps = <span class="keyword">this</span>.writeNewSplits(job, jobSubmitDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maps = <span class="keyword">this</span>.writeOldSplits(jConf, jobSubmitDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>单步进入this.writeNewSplits方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T extends InputSplit&gt; <span class="function"><span class="keyword">int</span> <span class="title">writeNewSplits</span><span class="params">(JobContext job, Path jobSubmitDir)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Configuration conf = job.getConfiguration();</span><br><span class="line">    InputFormat&lt;?, ?&gt; input = (InputFormat)ReflectionUtils.newInstance(job.getInputFormatClass(), conf);</span><br><span class="line">    <span class="comment">// 这里有一个获取切片的方法，返回一个切片集合</span></span><br><span class="line">    <span class="comment">// InputSplit（输入切片）：代表了要被单个map处理的数据，每一个map()操作只处理一个输入切片。</span></span><br><span class="line">    List&lt;InputSplit&gt; splits = input.getSplits(job);</span><br><span class="line">    T[] array = (InputSplit[])((InputSplit[])splits.toArray(<span class="keyword">new</span> InputSplit[splits.size()]));</span><br><span class="line">    Arrays.sort(array, <span class="keyword">new</span> JobSubmitter.SplitComparator());</span><br><span class="line">    JobSplitWriter.createSplitFiles(jobSubmitDir, conf, jobSubmitDir.getFileSystem(conf), array);</span><br><span class="line">    <span class="keyword">return</span> array.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>单步进入input.getSplits方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;InputSplit&gt; <span class="title">getSplits</span><span class="params">(JobContext job)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StopWatch sw = (<span class="keyword">new</span> StopWatch()).start();</span><br><span class="line">    <span class="comment">// this.getFormatMinSplitSize()获取格式化切片最小大小，返回的是一个固定的值：1L</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    public static long getMinSplitSize(JobContext job) &#123;</span></span><br><span class="line"><span class="comment">        return job.getConfiguration().getLong("mapreduce.input.fileinputformat.split.minsize", 1L);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    可以看到如果没有配置“mapreduce.input.fileinputformat.split.minsize”属性，默认值1L。</span></span><br><span class="line"><span class="comment">    去集群上查看一下（输入命令后发现，返回的是0）：</span></span><br><span class="line"><span class="comment">    [wbw@s201 /home/wbw]$hdfs getconf -confKey mapreduce.input.fileinputformat.split.minsize</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 所以minSize一定 &gt;=1</span></span><br><span class="line">    <span class="keyword">long</span> minSize = Math.max(<span class="keyword">this</span>.getFormatMinSplitSize(), getMinSplitSize(job));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static long getMaxSplitSize(JobContext context) &#123;</span></span><br><span class="line"><span class="comment">        return context.getConfiguration().getLong("mapreduce.input.fileinputformat.split.maxsize", 9223372036854775807L);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    去集群上查看一下（发现没有，那么取默认值9223372036854775807L）：</span></span><br><span class="line"><span class="comment">    [wbw@s201 /home/wbw]$hdfs getconf -confKey mapreduce.input.fileinputformat.split.maxsize</span></span><br><span class="line"><span class="comment">	Configuration mapreduce.input.fileinputformat.split.maxsize is missing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 所以maxSize一定 &lt;= Long.Max</span></span><br><span class="line">    <span class="keyword">long</span> maxSize = getMaxSplitSize(job);</span><br><span class="line">    List&lt;InputSplit&gt; splits = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List&lt;FileStatus&gt; files = <span class="keyword">this</span>.listStatus(job);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    FileStatus file;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!var10.hasNext()) &#123;</span><br><span class="line">                            <span class="comment">// ...</span></span><br><span class="line">                            <span class="keyword">return</span> splits;</span><br><span class="line">                        &#125;</span><br><span class="line">                        file = (FileStatus)var10.next();</span><br><span class="line">                    &#125; <span class="keyword">while</span>(ignoreDirs &amp;&amp; file.isDirectory());</span><br><span class="line"></span><br><span class="line">                    Path path = file.getPath();</span><br><span class="line">                    <span class="keyword">long</span> length = file.getLen();</span><br><span class="line">                <span class="keyword">if</span> (length != <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="comment">// isSplitable:如果是压缩文件，那么不可以切</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isSplitable(job, path)) &#123;</span><br><span class="line">                        <span class="comment">// 获取block块大小</span></span><br><span class="line">                        <span class="keyword">long</span> blockSize = file.getBlockSize();</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">protected long computeSplitSize(long blockSize, long minSize, long maxSize) &#123;</span></span><br><span class="line"><span class="comment">        return Math.max(minSize, Math.min(maxSize, blockSize));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">// 计算切片大小：即在块大小、最大（小）切片中取中间值</span></span><br><span class="line">                        <span class="keyword">long</span> splitSize = <span class="keyword">this</span>.computeSplitSize(blockSize, minSize, maxSize);</span><br><span class="line">						<span class="comment">// ...</span></span><br><span class="line">                        splits.add(<span class="keyword">this</span>.makeSplit(path, <span class="number">0L</span>, length, blkLocations[<span class="number">0</span>].getHosts(), blkLocations[<span class="number">0</span>].getCachedHosts()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    splits.add(<span class="keyword">this</span>.makeSplit(path, <span class="number">0L</span>, length, <span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>我们修改一下words.txt内容(查看属性，发现有49个字节。其中45个字母，有4个是回车换行)：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world tom			15 + 2（\r\n）</span><br><span class="line">tom hello world			15 + 2</span><br><span class="line">world tom hello			15</span><br></pre></td></tr></table></figure></div>

<p>再修改WordCount类，手动添加指定切片大小（一个块默认128M取中间值后，所以切片大小应该是13）：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置最大最小切片</span></span><br><span class="line">FileInputFormat.setMaxInputSplitSize(job, <span class="number">13L</span>);</span><br><span class="line">FileInputFormat.setMinInputSplitSize(job, <span class="number">1L</span>);</span><br></pre></td></tr></table></figure></div>

<p>接着重新debug程序：</p>
<p><a href="/postImages/split1.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/split1.png" class="lazyload"></a></p>
<p>可以看到，文件被切成了4片，每一片大小13。但是如果切13个字节的话，一行文本就被断掉了，数据就有问题了。</p>
<p><a href="/postImages/split2.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/split2.png" class="lazyload"></a></p>
<p><a href="/postImages/split3.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/split3.png" class="lazyload"></a></p>
<p><a href="/postImages/split4.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/split4.png" class="lazyload"></a></p>
<p>可以看到实际上，并没有，依然是一行一条。这就涉及到RecordReader阅读器了。</p>
</li>
</ol>
<h3 id="5-3-RecordReader读取法则"><a href="#5-3-RecordReader读取法则" class="headerlink" title="5.3 RecordReader读取法则"></a>5.3 RecordReader读取法则</h3><p>InputSplit描述了数据块的切分方式，RecordReader类则是实际用来加载split分片数据，并把数据转换为适合Mapper类里面map()方法处理的&lt;key, value&gt;形式。</p>
<p>接着 3.3 我们打断点，一步一步进入最后发现到了一个LineRecordReader类中的this.in.readLine方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Mapper&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setup(context);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*断点*/</span> <span class="keyword">while</span>(context.nextKeyValue()) &#123;</span><br><span class="line">		     <span class="keyword">this</span>.map(context.getCurrentKey(), context.getCurrentValue(), context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 打断点后发现，如果nextKeyValue返回的是false就会执行cleanup</span></span><br><span class="line">        <span class="keyword">this</span>.cleanup(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">截取自：https://blog.51cto.com/luchunli/1718322</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LineRecordReader类由一个FileSplit构造出来，start是这个FileSplit的起始位置，pos是当前读取分片的位置，end是分片结束位置，in是打开的一个读取这个分片的输入流，它是使用这个FileSplit对应的文件名来打开的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineRecordReader</span> <span class="keyword">extends</span> <span class="title">RecordReader</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(InputSplit genericSplit,TaskAttemptContext context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 接收split（FileSplit对象）分片，并通过分片解析出：</span></span><br><span class="line">        <span class="comment">//     分片起始位置：start = split.getStart();</span></span><br><span class="line">        <span class="comment">//     结束位置：end = start + split.getLength();</span></span><br><span class="line">        <span class="comment">//     文件位置：在HDFS上的绝对路径final Path file = split.getPath();</span></span><br><span class="line">        <span class="comment">// 2. 获取文件的输入流</span></span><br><span class="line">        <span class="comment">//     通过FileSystem获取文件，并获取输入流 fileIn = fs.open(file);</span></span><br><span class="line">        <span class="comment">// 3. 判定是否为压缩文件，并获取压缩格式</span></span><br><span class="line">        <span class="comment">//     CompressionCodec codec = new CompressionCodecFactory(job).getCodec(file);</span></span><br><span class="line">        <span class="comment">// 4. 计算行偏移量（原始解释如下）</span></span><br><span class="line">        <span class="comment">//     If this is not the first split, we always throw away first record</span></span><br><span class="line">        <span class="comment">//     because we always (except the last split) read one extra line in</span></span><br><span class="line">        <span class="comment">//     next() method.</span></span><br><span class="line">        <span class="keyword">if</span> (start != <span class="number">0</span>) &#123;</span><br><span class="line">            start += in.readLine(<span class="keyword">new</span> Text(), <span class="number">0</span>, maxBytesToConsume(start));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pos = start;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 最主要的方法就是nextKeyvalue()方法，由它获取分片上的下一个K-V 对。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nextKeyValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// key--&gt;这里为map task中map()函数的key</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">new</span> LongWritable();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取的是行偏移量</span></span><br><span class="line">        <span class="keyword">this</span>.key.set(<span class="keyword">this</span>.pos);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">new</span> Text();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newSize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 功能：多读取一些数据，补充完整的一行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.getFilePosition() &lt;= <span class="keyword">this</span>.end || <span class="keyword">this</span>.in.needAdditionalRecordAfterSplit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.pos == <span class="number">0L</span>) &#123;</span><br><span class="line">                newSize = <span class="keyword">this</span>.skipUtfByteOrderMark();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 判定split是否已经读取解析完成，如果未完成的话就读取一行数据</span></span><br><span class="line">                <span class="comment">// 通过org.apache.hadoop.util.LineReader的readCustomLine或readDefaultLine读取</span></span><br><span class="line">                <span class="comment">// 如果指定了行分隔符则调用readCustomLine；</span></span><br><span class="line">                <span class="comment">// 否则默认通过回车换行作为分隔符调用readDefaultLine</span></span><br><span class="line">                newSize = <span class="keyword">this</span>.in.readLine(<span class="keyword">this</span>.value, <span class="keyword">this</span>.maxLineLength, <span class="keyword">this</span>.maxBytesToConsume(<span class="keyword">this</span>.pos));</span><br><span class="line">                <span class="comment">// 偏移量加，上个读取的行的长度，作为下一行的偏移量</span></span><br><span class="line">                <span class="keyword">this</span>.pos += (<span class="keyword">long</span>)newSize;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newSize == <span class="number">0</span> || newSize &lt; <span class="keyword">this</span>.maxLineLength) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOG.info(<span class="string">"Skipped line of size "</span> + newSize + <span class="string">" at pos "</span> + (<span class="keyword">this</span>.pos - (<span class="keyword">long</span>)newSize));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结论：</p>
<ul>
<li>网友1(<a href="https://www.cnblogs.com/qincan4Q/p/9807877.html)：" target="_blank" rel="noopener">https://www.cnblogs.com/qincan4Q/p/9807877.html)：</a></li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里有个很重要的类Recordreader，inputformat到map中间有一个reader，你切片可以这样定义（就是代码定义的13），但是reader要去读数据，他会首先判断读取的位置是不是行首，若是，则会一直读到回车换行；若不是行首，它会从下一行开始读。这就是为什么我们第二个切片内容会是一个完整的行内容，而不是从第一行的 om 开始读。</span><br><span class="line"></span><br><span class="line">所以我们虽然有四个切片，但是我们只有前三个split有数据，最后一个split是空的，因为我们只有三行数据，依照reader的读取数据法则，到最后一个split的时候我们已近没有数据可读了。</span><br><span class="line"></span><br><span class="line">这里我们可能会问，split和reader这到底听谁的？或者他们俩的功能感觉差不多？</span><br><span class="line"></span><br><span class="line">假设split的大小是128M，我们读了n行数据，在第n行读了一半，如果不读剩下的，会丢数据，这里可能会说，下一个切片把数据读走再分析，但是在并发情况下，切片很大可能在不同节点上运行的，怎么把这两个数据对接在一起再分析。所以这时候就需要reader了，就算我们split值满了，我们还是要把这行读完。（reader是一行一行的把数据发给mapper的）</span><br><span class="line"></span><br><span class="line">切片是定义大方向的，而这个reader是处理细节，让你不丢失数据，或者数据不错乱。</span><br></pre></td></tr></table></figure></div>

<ul>
<li>网友2(<a href="https://blog.csdn.net/chengyuan2789/article/details/100839252)：" target="_blank" rel="noopener">https://blog.csdn.net/chengyuan2789/article/details/100839252)：</a></li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">那么一行数据，可能在不同的splits中，也可能在不同的block中。</span><br><span class="line"></span><br><span class="line">在不同的block中呢，这个有fileIn对象帮我们处理的了，主要是读取read到缓冲区，属于物理上的问题，不是考虑的地方。</span><br><span class="line"></span><br><span class="line">处于不同的split呢？这个情况有些问题，因为不同的split就是不同的划分，并且由不同的map task执行。</span><br><span class="line"></span><br><span class="line">那么我们recordreader如何解决这个问题呢？</span><br><span class="line"></span><br><span class="line">解决办法便是，突破split的start和end限制。</span><br><span class="line"></span><br><span class="line">linerecordreader的解决办法：</span><br><span class="line"></span><br><span class="line">只要start指向的位置不是文件的第一行，则默认的过滤掉一行（start位置可能是一行中的某一个位置，比如本例子切片定义的13，即第一行t&#x2F;om之间）。</span><br><span class="line"></span><br><span class="line">在nextKeyvalue方法中，多读取一些数据，补充完整的一行。</span><br><span class="line"></span><br><span class="line">OK，通过过滤掉一行，和多读取一行，就能保证被split分隔的一行，能够完成的读取，同时也不会重复处理一些数据。因为，所有的mapTask的linerecordreader都遵循这个方法。</span><br></pre></td></tr></table></figure></div>



<h2 id="六、数据库读取与写入"><a href="#六、数据库读取与写入" class="headerlink" title="六、数据库读取与写入"></a>六、数据库读取与写入</h2><p>数据的输入不仅仅可以从常用的TextInputFormat进行，还可以直接从数据库中读取和写入。</p>
<h3 id="6-1-数据库准备"><a href="#6-1-数据库准备" class="headerlink" title="6.1 数据库准备"></a>6.1 数据库准备</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> big4 ;</span><br><span class="line"><span class="keyword">use</span> big4 ;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> words(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment , <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) , txt <span class="built_in">varchar</span>(<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> words(<span class="keyword">name</span>,txt) <span class="keyword">values</span>(<span class="string">'tomas'</span>,<span class="string">'hello world tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> words(txt) <span class="keyword">values</span>(<span class="string">'hello tom world'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> words(txt) <span class="keyword">values</span>(<span class="string">'world hello tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> words(txt) <span class="keyword">values</span>(<span class="string">'world tom hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stats(word <span class="built_in">varchar</span>(<span class="number">50</span>),wordCount <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure></div>



<h3 id="6-2-自定义数据对象类"><a href="#6-2-自定义数据对象类" class="headerlink" title="6.2 自定义数据对象类"></a>6.2 自定义数据对象类</h3><p>首先我们回顾一下jdbc程序的读取/写入操作，关键是setXxx()方法和getXxx()方法。</p>
<ul>
<li><p>jdbc写操作</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection conn = DriverMananger.getConnection(<span class="string">"jdbc:mysql://localhost:3306/big4"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">PreparedStatement ppst = conn.preparedStatement(<span class="string">"insert into test(id,name,age) values(?,?,?)"</span>);</span><br><span class="line"><span class="comment">//绑定参数</span></span><br><span class="line">ppst.setInteger(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">ppst.setInteger(<span class="number">2</span>,<span class="string">"tom"</span>);</span><br><span class="line">ppst.setInteger(<span class="number">3</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">ppst.executeUpdate();</span><br><span class="line">ppst.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>jdbc读操作</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection conn = DriverMananger.getConnection(<span class="string">"jdbc:mysql://localhost:3306/big4"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">ppst = conn.preparedStatement(<span class="string">"select id,name from test "</span>);</span><br><span class="line">ResultSet rs = ppst.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">    String name = rs.getInt(<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br><span class="line">rs.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<p>然后，我们开始编写自定义数据对象类：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyDBWritable class</span></span><br><span class="line"><span class="comment"> * 自定义数据对象类</span></span><br><span class="line"><span class="comment"> * 实现DBWritable接口：由JDBC可以知道将数据读取/写入到数据库的时候，需要对预处理</span></span><br><span class="line"><span class="comment"> *      进行setXxx()，对返回的结果集进行getXxx()来吧数据写入到SQL语句，或者将返</span></span><br><span class="line"><span class="comment"> *      回结果写入对象。</span></span><br><span class="line"><span class="comment"> * 实现Writable接口：即上一章中的Hadoop中的序列化，来适配MR程序的输入输出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BoWenWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/24 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDBWritable</span> <span class="keyword">implements</span> <span class="title">DBWritable</span>, <span class="title">Writable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读表所需参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String txt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写表所需参数</span></span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> wordCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDBWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略get/set方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MR</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeInt(id);</span><br><span class="line">        dataOutput.writeUTF(name);</span><br><span class="line">        dataOutput.writeUTF(txt);</span><br><span class="line">        dataOutput.writeUTF(word);</span><br><span class="line">        dataOutput.writeInt(wordCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        id = dataInput.readInt();</span><br><span class="line">        name = dataInput.readUTF();</span><br><span class="line">        txt = dataInput.readUTF();</span><br><span class="line">        word = dataInput.readUTF();</span><br><span class="line">        wordCount = dataInput.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DB</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据库的只有2个参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(PreparedStatement preparedStatement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 这里注意顺序！</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, word);</span><br><span class="line">        preparedStatement.setInt(<span class="number">2</span>, wordCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库中读取数据，仅需3个参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        id = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">        name = resultSet.getString(<span class="number">2</span>);</span><br><span class="line">        txt = resultSet.getString(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="6-3-编写Mapper和Reducer"><a href="#6-3-编写Mapper和Reducer" class="headerlink" title="6.3 编写Mapper和Reducer"></a>6.3 编写Mapper和Reducer</h3><h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WCMapper class</span></span><br><span class="line"><span class="comment"> * 这里的输入KV类型是从数据库读取的，以LongWritable为key,自定义类为value</span></span><br><span class="line"><span class="comment"> * 注意这里的value，已经是将数据库中取到的记录封装到对象中了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BoWenWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/24 18:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WCMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">MyDBWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IntWritable SUM = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, MyDBWritable value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库字段txt为文本内容</span></span><br><span class="line">        String line = value.getTxt();</span><br><span class="line">        String[] words = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(word), SUM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WCReader class</span></span><br><span class="line"><span class="comment"> * 这里注意一点，通过对源码的跟踪发现：这里输出的value是泛型，且没有地方用到</span></span><br><span class="line"><span class="comment"> * 也就是说这个值是没有用的，因此用NullWritable，而Key就是我们的自定类，最后</span></span><br><span class="line"><span class="comment"> * 会将我们的自定义类，根据重写的write写入数据库。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BoWenWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/24 21:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WCReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">MyDBWritable</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        MyDBWritable rs = <span class="keyword">new</span> MyDBWritable();</span><br><span class="line">        rs.setWord(key.toString());</span><br><span class="line">        rs.setWordCount(count);</span><br><span class="line">        context.write(rs, NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="6-4-编写App启动类"><a href="#6-4-编写App启动类" class="headerlink" title="6.4 编写App启动类"></a>6.4 编写App启动类</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DBWCApp class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BoWenWang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/24 21:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBWCApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        <span class="comment">// 设置JOB属性</span></span><br><span class="line">        job.setJobName(<span class="string">"DBWCApp"</span>);</span><br><span class="line">        job.setJarByClass(DBWCApp<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 配置数据库连接信息</span></span><br><span class="line">        String driverClass = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost:3306/big4"</span>;</span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        String password = <span class="string">"root"</span>;</span><br><span class="line">        <span class="comment">// 将数据库配置写入job的配置属性中</span></span><br><span class="line">        DBConfiguration.configureDB(job.getConfiguration(), driverClass, url, username, password);</span><br><span class="line">        <span class="comment">// 设置数据输入，参数介绍：</span></span><br><span class="line">        <span class="comment">// 1、2：作业、和自定义类（因为里面重写了数据库读出和写入的函数）</span></span><br><span class="line">        <span class="comment">// 3：数据库查询语句</span></span><br><span class="line">        <span class="comment">// 4：表记录数（根据这个数量来计算切片数量）</span></span><br><span class="line">        DBInputFormat.setInput(job, MyDBWritable<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                "select id,name,txt from words", "select count(*) from words");</span><br><span class="line">        <span class="comment">// 设置数据输出，参数介绍：</span></span><br><span class="line">        <span class="comment">// 1：作业</span></span><br><span class="line">        <span class="comment">// 2：数据输出表名</span></span><br><span class="line">        <span class="comment">// 3：字段名（要和自定义类重写的write方法字段顺序一致）</span></span><br><span class="line">        DBOutputFormat.setOutput(job, <span class="string">"stats"</span>, <span class="string">"word"</span>, <span class="string">"wordCount"</span>);</span><br><span class="line">        <span class="comment">// 设置Map、Reduce</span></span><br><span class="line">        job.setMapperClass(WCMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(WCReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置输出KV类型</span></span><br><span class="line">        job.setOutputKeyClass(MyDBWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 提交作业</span></span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="6-5-添加pom依赖"><a href="#6-5-添加pom依赖" class="headerlink" title="6.5 添加pom依赖"></a>6.5 添加pom依赖</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="6-6-本地运行"><a href="#6-6-本地运行" class="headerlink" title="6.6 本地运行"></a>6.6 本地运行</h3><p><a href="/postImages/DB1.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/DB1.png" class="lazyload"></a></p>
<p>数据写入成功。</p>
<h3 id="6-7-集群运行"><a href="#6-7-集群运行" class="headerlink" title="6.7 集群运行"></a>6.7 集群运行</h3><ol>
<li><p>因为我们程序用到了mysql驱动类，而Hadoop中没有！所以我们要利用之前的方法，把mysql-connector-java-X.X.X.jar包放到Hadoop的lib目录下。【可以参照1.3内容】</p>
</li>
<li><p>分发jar包到所有节点的lib目录下，因为不知道程序实际运行在哪个节点上。</p>
</li>
<li><p>修改程序中的mysql的url地址，改成本地IP。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入cmd命令界面，输入ipconfig,找到IPV4地址，如我的：192.168.174.1</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>清空数据库输出表内容。</p>
</li>
<li><p>利用MAVEN打jar包上传。</p>
</li>
<li><p>启动集群，运行jar包。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop jar Hadoop-1.0-SNAPSHOT.jar cn.wangbowen.mr.db.DBWCApp</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>可能会报错不被允许连接数据库，这时候要对本地数据库进行一些设置：</p>
<p>可以参考 <a href="https://blog.csdn.net/yang5726685/article/details/52529082" target="_blank" rel="noopener">https://blog.csdn.net/yang5726685/article/details/52529082</a></p>
</li>
<li><p>查看WEB-UI 8088端口，发现有一个作业正常运行，等一会查看数据库。发现数据和本地的效果一致。</p>
<p><a href="/postImages/DB2.png" data-fancybox="group" data-caption="avatar" class="fancybox"><img alt="avatar" title="avatar" data-src="/postImages/DB2.png" class="lazyload"></a></p>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">IT小王</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wangbowen.cn/2020/02/24/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/">https://wangbowen.cn/2020/02/24/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wangbowen.cn">IT小王</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hadoop/">Hadoop    </a></div><div class="post_share"><div class="social-share" data-image="/postImages/HadoopCover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/26/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89HA/"><img class="prev_cover lazyload" data-src="/postImages/HadoopCover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Hadoop学习笔记（五）HA</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/22/Hexo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"><img class="next_cover lazyload" data-src="/postImages/HexoCover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Hexo使用入门</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/13/Hadoop学习笔记（一）Hadoop集群/" title="Hadoop学习笔记（一）Hadoop集群"><img class="relatedPosts_cover lazyload"data-src="/postImages/HadoopCover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-13</div><div class="relatedPosts_title">Hadoop学习笔记（一）Hadoop集群</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/16/Hadoop学习笔记（三）MapReduce/" title="Hadoop学习笔记（三）MapReduce"><img class="relatedPosts_cover lazyload"data-src="/postImages/HadoopCover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-16</div><div class="relatedPosts_title">Hadoop学习笔记（三）MapReduce</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/13/Hadoop学习笔记（二）HDFS/" title="Hadoop学习笔记（二）HDFS"><img class="relatedPosts_cover lazyload"data-src="/postImages/HadoopCover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-13</div><div class="relatedPosts_title">Hadoop学习笔记（二）HDFS</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/13/Hadoop学习笔记（零）前期准备/" title="Hadoop学习笔记（一）前期准备"><img class="relatedPosts_cover lazyload"data-src="/postImages/HadoopCover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-13</div><div class="relatedPosts_title">Hadoop学习笔记（一）前期准备</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'iYYoev4NDSyr3HqlY1VVCTIV-gzGzoHsz',
  appKey:'Hli8dWTFUKrXj9FnhnSQUvRe',
  placeholder:'快来评论吖！ヾﾉ≧∀≦)o',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By IT小王</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>闽ICP备18027071号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>